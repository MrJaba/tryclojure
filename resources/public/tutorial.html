<div id="tutorial">
  <div class="page" data-tag="start">
    <p>
      I'll take you on a 5-minutes tour of Clojure, but feel free to experiment on your own along the road!
    </p>
    <p>
      You can type <code>next</code> to skip
      forward, <code>back</code> to return to the previous step,
      and <code>restart</code> to get back to the beginning. Let's get
      started: type <code class="expr">next</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="(+ 3 3)">
    <p>
      The first thing you may notice about Clojure is that common operations look... strange.
    </p>
    <p>
      For example, try typing <code class="expr">(+ 3 3)</code> in the REPL.
    </p>
    <p>
      <em>Hint: you can click on the code samples to insert them in the
        REPL</em>
    </p>
  </div>
  <div class="page" data-exitexpr="(/ 10 3)">
    <p>
      That was a strange way to say "three plus three", wasn't it?
    </p>
    <p>
      A Clojure program is made of <em>lists</em>.
      <code class="expr">(+ 3 3)</code> is a list that contains an operator, and then the operands.
      Try out the same concept with the <code>*</code> and <code>-</code> operators.
    </p>
    <p>
      Division might surprise you. When you're ready to move forward, try <code class="expr">(/ 10 3)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="(/ 10 3.0)">
    <p>
      Now, that was a bit surprising: Clojure has a built in Rational
      type. You can still force Clojure to do floating point division
      by making one of the operands floating point:
      type <code class="expr">(/ 10 3.0)</code> to continue.
    </p>
  </div>
  <div class="page" data-exitexpr="(+ 1 2 3 4 5 6)">
    <p>Awesome!</p>
    <p>
      Many Clojure functions can take an arbitrary number of arguments.
      Try it out: type <code class="expr">(+ 1 2 3 4 5 6)</code> to continue.
    </p>
  </div>
  <div class="page" data-exitexpr="(defn square [x] (* x x))">
    <p>
      That's enough math. Let's do some fun stuff, like defining functions.
      You can do that in Clojure with <code>defn</code>.
    </p>
    <p>
      Type <code class="expr">(defn square [x] (* x x))</code> to define a "square" function that takes a single number and squares it.
    </p>
  </div>
  <div class="page" data-exitexpr="(square 10)">
    <p>Congratulations - you just defined your first Clojure function. Many more will follow!</p>
    <p>
      <code>defn</code> takes the name of the function, then the list of arguments, and then the body of the function.
      I told you that a Clojure program is made of lists, right?
      The entire <code>defn</code> is a list, and the function body is also a list.
      (Even the arguments are collected in a vector, which is similar to a list - we'll talk about vectors soon).
    </p>
    <p>
      Oh, sorry for talking so long - you probably want to try out your brand new function!
      Type <code class="expr">(square 10)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="((fn [x] (* x x)) 10)">
    <p>Yay! It works!</p>
    <p>
      By now, you probably think that Clojure is very different from
      the programming languages you already know. Indeed, it belongs to a
      different family than most popular languages' - the family of
      "functional" programming languages. Like most functional languages,
      Clojure can define a function without even giving it a name:
    </p>
    <code class="expr">(fn [x] (* x x))</code>
    <p>
      If you run this code, you'll see some cryptic output.
      In Clojure, functions are just normal values like numbers or strings.
      <code>fn</code> defines a function and then returns it.
      What you're seeing is simply what a function looks like when you print it on the screen.
    </p>
    <p>
      But wait - an anonymous function isn't very useful if you can't
      call it. Try to define a new anonymous function and call it
      straight
      away: <code class="expr">((fn [x] (* x x)) 10)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="(def square (fn [x] (* x x)))">
    <p>
      Let's see what you just did: you evaluated a list where the
      first element is the function itself, defined on the spot - and the
      other elements are the arguments that you pass to the function.
      That's exactly the same syntax that you used earlier on to call
      functions like <code>square</code> or even <code>+</code>. The only
      difference is that now you defined the function in the same place
      where you called it.
    </p>
    <p>
      Remember <code>defn</code>? Now I can tell you a
      secret: <code>defn</code> is actually just a bit of syntactic
      sugar around <code>def</code> and <code>fn</code>. You've just
      seen <code>fn</code> at work: it defines a new function.
      <code>def</code> binds the newly defined function to a name.
    </p>
    <p>
      If you want, you can create a named functions without
      using <code>defn</code>: type
      <pre class="codeblock"><code class="expr">(def square (fn [x] (* x x)))</code></pre>
      to continue.
    </p>
  </div>
  <div class="page" data-exitexpr="(map inc [1 2 3 4])">
    <p>
      Success! Now you can call this new <code>square</code> function
      just like you called the old <code>square</code> function.
    </p>
    <p>
      By now, you know that lists are quite important in Clojure.
      But Clojure also has other data structures:
    </p>
    <p>
      Vectors: <code class="expr">[1 2 3 4]</code><br/>
      Maps: <code class="expr">{:foo "bar" 3 4}</code><br/>
      Sets: <code class="expr">#{1 2 3 4}</code><br/>
    </p>
    <p>
      Vectors and lists are sequential and ordered collections.
      Sets are not ordered, and they cannot contain duplicate elements.
      Maps are key-value collections, where the keys can be any object.
      Here, we've used what Clojure calls a <em>keyword</em> (<code>:foo</code>) for one of the keys, and a number for the other key.
    </p>
    <p>
      Now I'll tell you another thing that may surprise you: Clojure
      collections are <em>immutable</em> - they can never change. When
      you do anything on a list, including adding and removing
      elements, you actually get a brand new list. (Fortunately,
      Clojure is amazingly efficient at creating new lists). In
      general, Clojure encourages you to have as little mutable state
      as possible. For example, instead qof "for" loops and other
      state-changing constructs, most of the time you'll see functions
      doing transformations on immutable data and returning new
      collections, without changing the old one.
    </p>
    <p>
      A prime example of this is <code>map</code>. <code>map</code> is
      a <em>higher order function</em>, which means that it takes
      another function as an argument. For example, you can
      ask <code>map</code> to increment each number in a vector by
      passing it the <code>inc</code> function, followed by the
      vector. Try it for yourself: type
      <code class="expr">(map inc [1 2 3 4])</code> to continue.
    </p>
  </div>
  <div class="page">
    <p>Great job!</p>
    <p>
      I told you that Clojure's data structures are immutable. Let's take
      a closer look at what that means.
    </p>
    <p>
      When you used the <code>map</code> function above to transform the
      vector <code>[1 2 3 4]</code>, the original vector was unchanged.
      Let's give our vector a name: type
      <code class="expr">(def v [1 2 3 4])</code>.
      Entering <code class="expr">v</code> at the REPL
      prints the value of <code>v</code> to the console.
    </p>
    <p>
      Now try <code class="expr">(map inc v)</code>, then
      type <code class="expr">v</code> again - it remains unchanged!
    </p>
    <p>
      We can use the <code>conj</code> function to add elements to a
      vector: try <code class="expr">(conj v 5)</code>.
    </p>
    <p>
      Now examine <code>v</code> - it is still the vector
      <code>[1 2 3 4]</code>. Clojure has returned a new vector
      with the value <code>5</code> added no the end. Clojure uses
      <em>structural sharing</em> to manage these immutable data
      structures in a memory-efficient manner.
    </p>
    <p>
      Type <code class="expr">next</code> to continue.
    </p>
  </div>
  <div class="page" data-tag="sudoku" data-exitexpr="(range 10)">
    <p>
      Let's put some of the things we have learned to work. We're
      going to write a function to solve Sudoku puzzles. (If
      you're not familiar with Sudoku, you might want to
      <a href="http://en.wikipedia.org/wiki/Sudoku" target="_blank">
        read about it</a> before coming back here.)
    </p>
    <p>
      Each cell in the Sudoku grid can contain any of the digits 1-9.
      We can use the <code>range</code> function to generate a list of
      integers.  Try it out: <code class="expr">(range 10)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="(range 1 10)">
    <p>
      That generated the list of numbers from 0-9, which might
      surprise you. When called with a single argument, <code>(range end)</code>,
      it returns a list of integers from 0 up to (but not
      including) <code>end</code>.
    </p>
    <p>
      With two arguments,
      <code>(range start end)</code>, it returns the
      numbers from <code>start</code> up to (but not
      including) <code>end</code>. An optional third argument
      specifies the step size; try
      <code class="expr">(range 1 50 5)</code>.
    </p>
    <p>
      Experiment with the <code>range</code> function and, when you're
      ready to continue, generate the list 1-9 we need for our Sudoku
      grid.
    </p>
  </div>
  <div class="page" data-exitexpr="(def candidates (set (range 1 10)))">
    <p>
      That was easy!
    </p>
    <p>
      It will be convenient to store the candidates for each cell as a
      set. We can use the <code>set</code> function to turn the
      sequence generated by <code>range</code> into a set. Type
      <code class="expr">(def candidates (set (range 1 10)))</code> to
      continue.
    </p>
  </div>
  <div class="page" data-exitexpr="(cell-index 7 2)">
    <p>
      We have the set of candidates for each cell, but we also need to
      decide how to represent the 9x9 grid. The simplest data
      structure we can use is an 81-element vector, with the first
      element (index 0) representing the top left of the grid (column
      0, row 0), and the 81st element (index 80) the bottom right
      (column 8, row 8). Note that we are using coordinates counting
      from 0 - this makes some of the arithmetic we have to do later a
      bit simpler.
    </p>
    <p>
      With this in mind, can you complete this function definition?
      <code>(defn cell-index [col row] ...)</code>.
      Test your function by computing the index of column 7, row 2.
    </p>
  </div>
  <div class="page" data-exitexpr="(get empty-grid (cell-index 3 4))">
    <p>
      Did your function return the value 25? If not, evaluate the
      following code to define <code>cell-index</code>:
    </p>
    <pre class="codeblock"><code class="expr">(defn cell-index [col row] (+ col (* 9 row)))</code></pre>
    <p>
      We will represent our (unsolved) Sudoku grid as a vector of candidates for
      each cell. Let's define the empty grid, where the values of all cells are
      unknown:
    </p>
    <pre class="codeblock"><code class="expr">(def empty-grid (vec (repeat 81 candidates)))</code></pre>
    <p>
      Like we used <code>set</code> to turn the sequence generated
      by <code>range</code> into a set, here we are
      using <code>vec</code> to turn the sequence generated
      by <code>repeat</code> into a vector.
    </p>
    <p>
      To continue, try combining the core function <code>get</code>
      with your <code>cell-index</code> function to retrieve the
      candidates for column 3, row 4 from the empty grid.
    </p>
  </div>
  <div class="page" data-exitexpr='(re-seq #"\d" puzzle)'>
    <p>
      Well done!
    </p>
    <p>
      Now, if we're going to solve Sudoku puzzles, we need to read a string
      representation of the puzzle into our grid of candidates. If we
      use <code>0</code> to represent an unknown value, we can
      represent the puzzle like so:
    </p>
    <pre class="codeblock"><code class="expr">(def puzzle "530070000
             600195000
             098000060
             800060003
             400803001
             700020006
             060000280
             000419005
             000080079")</code></pre>
    <p>
      We need to transform this into a sequence of integers that we can
      use to initialize our grid. Let's use a regular expression to
      pick out the digits:
    </p>
    <code class="expr">
      (re-seq #"\d" puzzle)
    </code>
  </div>
  <div class="page" data-exitexpr='(map parse-int (re-seq #"\d" puzzle))'>
    <p>
      That's close to what we're looking for, we just need to convert
      these strings into numbers. Java's <code>Integer</code> class
      has a static method for doing just that, and as we're runnnig
      Clojure on the JVM, we can simply use Clojure's Java
      interoperability support. Define the following:
    </p>
    <code class="expr">
      (defn parse-int [s] (Integer/parseInt s))
    </code>
    <p>
      With that in hand, try:
    </p>
    <code class="expr">
      (map parse-int (re-seq #"\d" puzzle))
    </code>
  </div>
  <div class="page">
    <p>
      You might be thinking that we need to loop over this list of
      integers to build our grid. Well, we <em>could</em>, but in
      Clojure explicit looping is very rare - we usually reach for a
      higher-order function.
    </p>
    <p>
      Let's define one more helper function. This function will take a
      digit <code>d</code> and return the set of candidates for the
      cell. If <code>d</code> is zero, this will just be the
      set <code>candidates</code> we defined earlier. Otherwise, it
      will be the set containing the single element <code>d</code>.
      The <code>set</code> function we used earlier expects a list as
      its first argument, so we could wrap <code>d</code> in a vector
      and write:
      <code class="expr">(set [d])</code>, but we prefer to use its
      sister function, <code>hash-set</code>:
    </p>
    <pre class="codeblock"><code class="expr">(defn candidates-for [d]
  (if (zero? d) candidates (hash-set d)))</code></pre>
    <p>
      Try it out for a few values of <code>d</code>, and
      type <code class="expr">next</code> when you're ready to
      continue.
    </p>
  </div>
  <div class="page" data-exitexpr='(def grid (map (comp candidates-for parse-int) (re-seq #"\d" puzzle)))'>
    <p>
      With this helper function in hand, we can use <code>map</code>
      to build our grid. Try:
    </p>
    <pre class="codeblock"><code class="expr">(def grid (map candidates-for
              (map parse-int (re-seq #"\d" puzzle))))</code></pre>
    <p>
      When you see two invocations of <code>map</code> together like
      this, you might be thinking there is a better way to express
      the solution, and you'd be right! We can use Clojure's <code>comp</code> function to <em>compose</em>
      the two functions:
    </p>
    <pre class="codeblock"><code class="expr">(def grid (map (comp candidates-for parse-int)
               (re-seq #"\d" puzzle)))</code></pre>
  </div>
  <div class="page" data-exitexpr="(get grid (cell-index 4 5))">
    <p>
      We're almost there! Let's look at the data type of <code>grid</code>:
    </p>
    <code class="expr">
      (type grid)
    </code>
    <p>
      We have generated a <em>list</em> (actually a <em>lazy
      sequence</em>, but we can think of it as a list). Lists and
      vectors in Clojure have different properties, one of those differences
      being that vectors support fast indexed access while indexed
      access to a list takes linear time. This won't make much difference
      to performance when our list is only 81 elements long, but let's not get
      into bad habits when we're just starting out.
    </p>
    <p>
      We could wrap the output in a call to <code>vec</code>, like we did to
      create an empty grid, but returning a vector from <code>map</code> is a common
      enough occurrence that Clojure provides a function for just this purpose, namely <code>mapv</code>.
      Let's put everything together into a function that parses a puzzle and returns the candidates
      grid as a vector:
    </p>
    <pre>
      <code class="expr">
        (defn parse-puzzle [puzzle]
          (mapv (comp candidates-for parse-int)
                (re-seq #"\d" puzzle)))
      </code>
    </pre>
    <p>
      New we can define our grid:
    </p>
    <code class="expr">(def grid (parse-puzzle puzzle))</code>
    <p>
      What are the candidates for the cell at column 4, row 5?
    </p>
  </div>
  <div class="page" data-exitexpr="true">
    <p>
      Before we go on to solve the puzzle, let's write a function to
      pretty-print our grid. We'd like the output to look like:
    </p>
    <pre>
      +---+---+---+
      |53.|.7.|...|
      |6..|195|...|
      |.98|...|..6|
      +---+---+---+
      |8..|.6.|..3|
      |4..|8.3|..1|
      |7..|.2.|..6|
      +---+---+---+
      |.6.|...|28.|
      |...|419|..5|
      |...|.8.|.79|
      +---+---+---+
    </pre>
    <p>
      First, let's write a function to render a cell. If the cell is a number, or a set of
      candidates with only one element, we should render the number, otherwise a dot.
    </p>
    <pre>
      <code class="expr">
        (defn render-cell [x]
          (cond
            (number? x)     x
            (= (count x) 1) (first x)
            :else           "."))
      </code>
    </pre>
    <p>
      This is the first time we've seen <code>cond</code>, which is
      similar to a <code>switch</code> statement in other languages.
      There's nothing special about the <code>:else</code> keyword in
      the last branch - any truthy value would do.
    </p>
    <p>
      Type <code class="expr">true</code> to continue.
    </p>
  </div>
  <div class="page" data-exitexpr="(row-render-values grid 4)">
    <p>
      Let's write a function to pull out the rendered values for a
      given row. You'll see we're using the function <code>for</code> below. This
      does <strong>not</strong> introduce a loop like <code>for</code> does in
      some other languages. In Clojure, <code>for</code> is
      a <a href="http://en.wikipedia.org/wiki/List_comprehension">list
      comprehension</a>. This is a very powerful construct, and we'll see
      more of it later.
    </p>
    <pre>
      <code class="expr">
        (defn row-render-values [grid row]
          (for [col (range 9) :let [cell (get grid (cell-index col row))]]
            (render-cell cell)))
      </code>
    </pre>
    <p>
      Try it: <code class="expr">(row-render-values grid 4)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr='["|" (interpose "|" (partition 3 (range 9))) "|"]'>
    <p>
      Now, we need to partition these values into groups of 3 and
      interpose pipe symbols. Luckily, Clojure comes with <code>partiiton</code>
      and <code>interpose</code> functions!
      Try <code class="expr">(partition 3 (range 9))</code> and
      <code class="expr">(interpose "|" (partition 3 (range 9)))</code>.
    </p>
    <p>
      Of course, we need a pipe at the beginning and the end of each row too:
      <code class="expr">["|" (interpose "|" (partition 3 (range 9))) "|"]</code>
    </p>
  </div>
  <div class="page" data-exitexpr='(apply str (flatten ["|" (interpose "|" (partition 3 (range 9))) "|"]))'>
    <p>
      We've got all the characters we need to render in the right
      order, but unfortunately we've ended up with a nested data
      structure, not a string we can print. Once again, Clojure's core
      library has a function that comes to our rescue:
    </p>
    <pre>
      <code class="expr">
        (flatten ["|" (interpose "|" (partition 3 (range 9))) "|"])
      </code>
    </pre>
    <p>
      We need one more trick to render this row. If we try to print
      the list returned by <code>flatten</code>, we won't get quite
      the right output. Try <code class="expr">(str ["A" "ba" "cus"])</code>
      and compare that output with <code class="expr">(str "A" "ba" "cus")</code>.
      See the difference? The <code>str</code> function expects to be called
      with multiple arguments, not a single (list) argument. To get
      the results we desire, we have to <code>apply</code>
      the <code>str</code> function to the list returned
      by <code>flatten</code>, making it behave as if we'd
      called <code>str</code> with multiple arguments:
    </p>
    <pre>
      <code class="expr">
        (apply str (flatten ["|" (interpose "|" (partition 3 (range 9))) "|"]))
      </code>
    </pre>
  </div>
  <div class="page" data-exitexpr="(render-grid-row grid 4)">
    <p>
      With this in hand, we can render a grid row!
    </p>
    <pre class="codeblock"><code class="expr">(defn render-grid-row [grid row]
  (apply str
    (flatten
      ["|" (interpose "|" (partition 3 (row-render-values grid row))) "|"])))</code></pre>
    <p>
      Try it: <code class="expr">(render-grid-row grid 4)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="(map (partial render-grid-row grid) (range 9))">
    <p>
      We're going to have to call <code>(render-grid-row grid row</code>
      for values of <code>row</code> ranging from 0 to 8.
      Hopefully by now you'll realise that this is a prime candidate
      for <code>map</code>. We could write:
    </p>
    <pre>
      <code class="expr">
        (map (fn [row] (render-grid-row grid row)) (range 9))
      </code>
    </pre>
    <p>
      ...and, while that would be perfectly fine, we could also use <code>(partial render-grid-row grid)</code>
      create a new function that is just like <code>render-grid-row</code>, but with the first argument pre-populated.
    </p>
    <pre>
      <code class="expr">
        (map (partial render-grid-row grid) (range 9))
      </code>
    </pre>
  </div>
  <div class="page">
    <p>
      When it comes to rendering the grid, we need to print a horizontal separator at the start
      and end, and between every 3 rows.
    </p>
    <pre>
      <code class="expr">
        (def hsep "+---+---+---+")
      </code>
    </pre>
    <p>
      We can use <code>flatten</code>, <code>interpose</code> and <code>partition</code>
      to build the grid, like we did for each row:
    </p>
    <pre>
      <code class="expr">
        (flatten [hsep (interpose hsep (partition 3 (map (partial render-grid-row grid) (range 9)))) hsep])
      </code>
    </pre>
    <p>
      Let's put all this together to build our <code>render-grid</code> function.
    </p>
    <pre>
      <code class="expr">
        (defn render-grid [grid]
          (let [hsep "+---+---+---+"
                rows (map (partial render-grid-row grid) (range 9))]
            (doseq [line (flatten [hsep (interpose hsep (partition 3 rows)) hsep])]
              (println line))))
      </code>
    </pre>
    <p>
      To continue, type <code class="expr">(render-grid grid)</code>.
    </p>
  </div>
  <div class="page" data-exitexpr="(square-peers 4 5)">
    <p>
      We're going to solve the puzzle using a combination
      of <em>assignment</em>, <em>elimination</em> and <em>search</em>
      (more on this later). When we <em>assign</em> the value 6 to the
      cell (0,1), no other cells in the same row, column or 3x3 square
      can have the value 6 - so we <em>eliminate</em> it from the
      corresponding candidate lists.
    </p>
    <p>
      We call the cells we have to eliminate when assigning a value to
      a cell its <em>peers</em>, and we're going to need a function to
      return the list of peers of a given cell. We'll build
      the <code>peers</code> function from three helper
      functions, <code>row-peers</code>, <code>col-peers</code>
      and <code>square-peers</code>.
    </p>
    <p>
      Let's define <code>row-peers</code>:
      <pre>
        <code class="expr">(defn row-peers [col row] (for [x (range 9)] [x row]))</code>
      </pre>
    </p>
    <p>
      <code>col-peers</code> is almost the same:
      <pre>
        <code class="expr">(defn col-peers [col row] (for [y (range 9)] [col y]))</code>
      </pre>
    </p>
    <p>
      We have to work a little bit harder to calculate the minor square for a cell. We calculate the
      row and column of the top-left corner, and return the cells up to 3 columns to the right and 3 rows down.
      <pre>
        <code class="expr">
          (defn square-peers [col row]
             (let [top-left-col (* 3 (quot col 3))
                   top-left-row (* 3 (quot row 3))]
               (for [delta-row (range 3) delta-col (range 3)]
                 [(+ top-left-col delta-col) (+ top-left-row delta-row)])))
        </code>
      </pre>
      <p>
        Try it out: <code class="expr">(square-peers 4 5)</code>.
      </p>
  </div>
  <div class="page">
    <p>
      Glad to know you're eager for more, but unfortunately this tutorial is over.
    </p>
    <p>
      Maybe you can click the 'links' button below for more resources?
    </p>
  </div>
</div>
